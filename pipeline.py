import subprocess
import json
import os
from pathlib import Path
import networkx as nx
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.patches import Patch
from dotenv import load_dotenv

class GraphRAGPipeline:
    """
    A class to manage the GraphRAG indexing and querying pipeline.
    This class provides methods to run indexing, perform global and local searches,
    and retrieve information about generated artifacts.
    """

    def __init__(self, project_root: str = "./") -> None:
        """
        Initialize the GraphRAGPipeline with the project root directory.
        """
        self.project_root = Path(project_root)
        load_dotenv()

    def run_indexing(self) -> bool:
        """
        Run the GraphRAG indexing pipeline.

        Returns:
            bool: True if indexing was successful, False otherwise
        """
        print("Starting GraphRAG indexing...")

        try:
            cmd = (
                f"graphrag index --root {str(self.project_root)}"
            )
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                check=False
            )

            if result.returncode != 0:
                print(f"Indexing failed with exit code {result.returncode}")
                print(f"Error output: {result.stderr}")
                return False

            print("Indexing completed successfully!")
            print(result.stdout)
            return True

        except Exception as e:
            print(f"Indexing failed: {e}")
            return False

    def search(self, query: str) -> str:
        """
        Perform search query.

        Args:
            query: The query string to search for

        Returns:
            str: The search results
        """
        print(f"Running search for: {query}")

        try:
            cmd = (
                f"graphrag query --root {str(self.project_root)} "
                f"--method local --query \"{query}\""
            )

            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                check=False
            )

            if result.returncode != 0:
                print(f"Search failed with exit code {result.returncode}")
                print(f"Error output: {result.stderr}")
                return f"Search failed. Error: {result.stderr}"

            return result.stdout

        except Exception as e:
            print(f"Search failed: {e}")
            return f"Search failed due to an error: {str(e)}"


    def visualize_graph(
            self,
            output_path: str = "knowledge_graph.png",
            figsize: tuple[int, int] = (12, 8)
        ) -> bool:
        """
        Visualize the knowledge graph generated by GraphRAG.

        Args:
            output_path: Path to save the visualization image
            figsize: Figure size as a tuple (width, height)

        Returns:
            bool: True if visualization was successful, False otherwise
        """
        try:
            # Check if output directory exists, create it if it doesn't
            output_dir = os.path.join(self.project_root, "output")

            # Try to find the entities and relationships data
            entities_path = os.path.join(output_dir, "entities.json")
            relationships_path = os.path.join(output_dir, "relationships.json")
            if not os.path.exists(entities_path) or not os.path.exists(relationships_path):
                print(f"Graph data files not found: {entities_path} or {relationships_path}")
                return False

            # Load the entities and relationships
            with open(entities_path, 'r', encoding='utf-8') as f:
                entities_data = json.load(f)

            with open(relationships_path, 'r', encoding='utf-8') as f:
                relationships_data = json.load(f)

            # Create a NetworkX graph
            G = nx.DiGraph()

            # Add nodes from entities
            for entity in entities_data:
                entity_id = entity.get('id')
                if entity_id:
                    G.add_node(entity_id, **entity)

            # Add edges from relationships
            for rel in relationships_data:
                source = rel.get('source')
                target = rel.get('target')
                if source and target:
                    G.add_edge(source, target, **rel)

            # Check if we have a valid graph
            if len(G.nodes) == 0:
                print("No nodes found in the graph data")
                return False

            print(f"Graph loaded with {len(G.nodes)} nodes and {len(G.edges)} edges")

            # Create the visualization
            plt.figure(figsize=figsize)

            # Create a mapping of node types to colors
            node_types = set()
            for _, node_data in G.nodes(data=True):
                node_type = node_data.get('type', node_data.get('entity_type', 'Unknown'))
                node_types.add(node_type)

            color_map = {}
            colors = list(mcolors.TABLEAU_COLORS)
            for i, node_type in enumerate(node_types):
                color_map[node_type] = colors[i % len(colors)]

            # Get node colors based on type
            node_colors = []
            for node in G.nodes():
                node_data = G.nodes[node]
                node_type = node_data.get('type', node_data.get('entity_type', 'Unknown'))
                node_colors.append(color_map.get(node_type, 'gray'))

            # Get node labels
            node_labels = {}
            for node in G.nodes():
                node_data = G.nodes[node]
                label = node_data.get('name', node_data.get('title', str(node)))
                # Truncate long labels
                if len(label) > 20:
                    label = label[:17] + "..."
                node_labels[node] = label

            # Use spring layout for visualization
            pos = nx.spring_layout(G, k=0.5, iterations=50)

            # Draw nodes
            nx.draw(
                G,
                pos,
                with_labels=True,
                labels=node_labels,
                node_size=3000,
                node_color=node_colors,
                font_size=10,
                font_weight="bold",
                arrowsize=15
            )

            # Draw edge labels if there aren't too many edges
            if len(G.edges) < 50:
                edge_labels = {}
                for u, v, data in G.edges(data=True):
                    relation = data.get('relation', data.get('type', ''))
                    if relation:
                        edge_labels[(u, v)] = relation
                nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels, font_size=8)

            # Add a legend
            legend_elements = [Patch(facecolor=color, label=node_type)
                              for node_type, color in color_map.items()]
            plt.legend(handles=legend_elements, loc='upper right')

            plt.title("Knowledge Graph")

            # Save the visualization
            plt.savefig(output_path)
            plt.close()

            print(f"Graph visualization saved to {output_path}")
            return True

        except Exception as e:
            print(f"Error visualizing graph: {str(e)}")
            return False
